-- Add up migration script here
-- Create urls, alias tables
BEGIN;

CREATE EXTENSION IF NOT EXISTS pgcrypto;

CREATE TABLE IF NOT EXISTS urls (
  id       BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  code     VARCHAR(12) COLLATE "C" NOT NULL UNIQUE,
  url      TEXT NOT NULL,
  url_hash BYTEA GENERATED ALWAYS AS (digest(url, 'sha256')) STORED
);


CREATE UNIQUE INDEX IF NOT EXISTS uniq_url_hash ON urls (url_hash) INCLUDE (id);

ALTER INDEX IF EXISTS urls_code_key SET (fillfactor = 90);
ALTER INDEX IF EXISTS uniq_url_hash SET (fillfactor = 90);

CREATE TABLE IF NOT EXISTS aliases (
  alias VARCHAR(64) COLLATE "C" PRIMARY KEY,
  target_id BIGINT NOT NULL REFERENCES urls(id) ON DELETE CASCADE
);
CREATE INDEX IF NOT EXISTS aliases_target_id_idx ON aliases (target_id);

CREATE OR REPLACE FUNCTION trg_alias_not_in_urls()
RETURNS trigger LANGUAGE plpgsql AS $$
BEGIN
  IF EXISTS (SELECT 1 FROM urls WHERE code = NEW.alias) THEN
    RAISE EXCEPTION 'alias % conflicts with existing primary code', NEW.alias
      USING ERRCODE = '23505';
  END IF;
  RETURN NEW;
END $$;

DROP TRIGGER IF EXISTS aliases_block_overlap ON aliases;
CREATE TRIGGER aliases_block_overlap
  BEFORE INSERT OR UPDATE ON aliases
  FOR EACH ROW EXECUTE FUNCTION trg_alias_not_in_urls();

CREATE OR REPLACE FUNCTION trg_code_not_in_aliases()
RETURNS trigger LANGUAGE plpgsql AS $$
BEGIN
  IF EXISTS (SELECT 1 FROM aliases WHERE alias = NEW.code) THEN
    RAISE EXCEPTION 'code % conflicts with existing alias', NEW.code
      USING ERRCODE = '23505';
  END IF;
  RETURN NEW;
END $$;

DROP TRIGGER IF EXISTS urls_block_overlap ON urls;
CREATE TRIGGER urls_block_overlap
  BEFORE INSERT OR UPDATE ON urls
  FOR EACH ROW EXECUTE FUNCTION trg_code_not_in_aliases();

CREATE OR REPLACE VIEW all_short_codes AS
  SELECT
    u.code        AS code,
    u.id          AS target_id,
    u.url         AS url,
    'code'::text  AS source
  FROM urls u

  UNION ALL

  SELECT
    a.alias       AS code,
    a.target_id   AS target_id,
    u.url         AS url,
    'alias'::text AS source
  FROM aliases a
  JOIN urls u ON u.id = a.target_id;

CREATE OR REPLACE FUNCTION public.upsert_url(_code text, _url text)
RETURNS TABLE(id bigint, created boolean)
LANGUAGE plpgsql AS $$
BEGIN
  RETURN QUERY
  INSERT INTO urls(code, url) VALUES (_code, _url) ON CONFLICT (url_hash) DO NOTHING
  RETURNING urls.id, TRUE;

  IF FOUND THEN
    RETURN;
  END IF;

  RETURN QUERY
  SELECT u.id, FALSE FROM urls u WHERE u.url_hash = digest(_url, 'sha256') LIMIT 1;

  RETURN;
END $$;

COMMIT;

